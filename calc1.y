%{
#include <iostream>
#include <math.h>
#include "util.h"

int yylex(); // A function that is to be generated and provided by flex,
             // which returns a next token when called repeatedly.
int yyerror(const char *p) { std::cerr << "error: " << p << std::endl; };
%}

%union {
    float val;
    /* You may include additional fields as you want. */
    /* char op; */
};

%start prog

%token LPAREN RPAREN
%token PLUS MINUS MUL DIV POW EQUALS
%token SIN COS TAN
%token MOD FLOOR CEIL ABS
%token LOG2 LOG10
%token PI
%token GBP_TO_USD USD_TO_GBP GBP_TO_EURO EURO_TO_GBP USD_TO_EURO EURO_TO_USD CEL_TO_FAH FAH_TO_CEL MI_TO_KM KM_TO_MI
%token VAR_KEYWORD 
%token <val> NUM VARIABLE
%token EOL

%type <val> expr term power factor trig_function standard_function log_function conversion

%%

prog : calcs EOL                        { YYACCEPT; }
     | EOL                              { YYACCEPT; }
     ;

calcs: calc
     | calcs calc
     ;

calc: expr EOL                          { std::cout << $1 << std::endl; }
     | assignment EOL
     ;

expr : expr PLUS term                   { $$ = $1 + $3; }
     | expr MINUS term                  { $$ = $1 - $3; }
     | term                             /* default action: { $$ = $1; } */
     | trig_function
     | standard_function
     | log_function
     | conversion
     | VARIABLE
     ;

term : term MUL factor                  { $$ = $1 * $3; }
     | term DIV factor                  { $$ = $1 / $3; }
     | power                           /* default action: { $$ = $1; } */
     ;

power : factor POW factor               { $$ = pow($1, $3); }
     | factor
     ;

factor : NUM                            /* default action: { $$ = $1; } */
     | PI                               { $$ = 3.14; }
     | LPAREN expr RPAREN               { $$ = $2; }
     ; 


trig_function : COS factor              { $$ = cos($2); }
     | SIN factor                       { $$ = sin($2); }
     | TAN factor                       { $$ = tan($2); }
     ;

standard_function : expr MOD factor     { $$ = modulo($1, $3); }
     | FLOOR factor                     { $$ = floor($2); }
     | CEIL factor                      { $$ = ceil($2); }
     | ABS factor                       { $$ = fabs($2); }
     ;

log_function : LOG2 factor              { $$ = log2($2); }
     | LOG10 factor                     { $$ = log10($2); }  
     ;

conversion : expr GBP_TO_USD            { $$ = gbp_to_usd($1); }
     | expr USD_TO_GBP                  { $$ = usd_to_gbp($1); } 
     | expr GBP_TO_EURO                 { $$ = gbp_to_euro($1); }
     | expr EURO_TO_GBP                 { $$ = euro_to_gbp($1); }
     | expr USD_TO_EURO                 { $$ = usd_to_gbp($1); }
     | expr EURO_TO_USD                 { $$ = euro_to_gbp($1); }
     | expr CEL_TO_FAH                  { $$ = cel_to_fah($1); }
     | expr FAH_TO_CEL                  { $$ = fah_to_cel($1); }
     | expr MI_TO_KM                    { $$ = m_to_km($1); }
     | expr KM_TO_MI                    { $$ = km_to_m($1); }

assignment : VAR_KEYWORD VARIABLE EQUALS expr {}
%%

int main()
{
    yyparse(); // A parsing function that will be generated by Bison.
    return 0;
}
