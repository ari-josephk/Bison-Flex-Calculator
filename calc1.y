%{
#include <iostream>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "util.h"
#include "var.h"

int yylex(); // A function that is to be generated and provided by flex,
             // which returns a next token when called repeatedly.
int yyerror(const char *p) { std::cerr << "error: " << p << std::endl; };
%}

%union {
    float val;
    char id[64];
    /* You may include additional fields as you want. */
    /* char op; */
};

%start prog

%token LPAREN RPAREN
%token PLUS MINUS MUL DIV POW EQUALS
%token SIN COS TAN
%token MOD FLOOR CEIL ABS SQRT
%token LOG2 LOG10
%token PI
%token GBP_TO_USD USD_TO_GBP GBP_TO_EURO EURO_TO_GBP USD_TO_EURO EURO_TO_USD CEL_TO_FAH FAH_TO_CEL MI_TO_KM KM_TO_MI
%token FACTORIAL
%token VAR_KEYWORD 
%token <val> NUM
%token <id> VARIABLE
%token EOL

%type <val> expr term power factor function trig_function standard_function log_function conversion 

%%

prog : calcs EOL                        { YYACCEPT; }
     | EOL                              { YYACCEPT; }
     ;

calcs: calc
     | calcs calc
     ;

calc: expr EOL                          { std::cout << $1 << std::endl; }
     | assignment
     ;

expr : expr PLUS term                   { $$ = $1 + $3; }
     | expr MINUS term                  { $$ = $1 - $3; }
     | term                            /* default action: { $$ = $1; } */
     ;

term : term MUL factor                  { $$ = $1 * $3; }
     | term DIV factor                  { $$ = $1 / $3; }
     | term LPAREN expr RPAREN          { $$ = $1 * $3; }
     | power 
     | function                          /* default action: { $$ = $1; } */
     ;

power : factor POW factor               { $$ = pow($1, $3); }
     | factor
     ;

factor : NUM                            /* default action: { $$ = $1; } */
     | MINUS factor                     { $$ = -$2; }
     | PI                               { $$ = 3.14; }
     | LPAREN expr RPAREN               { $$ = $2; }
     | VARIABLE                         {
                                             var *a = get_var($1);
                                             if(a) $$ = a->val;
                                             else {
                                                  std::cout << $1 << " not defined!" << std::endl;
                                                  YYABORT;
                                             }
                                        }
     ; 

function:  trig_function
     | standard_function
     | log_function
     | conversion
     ;

trig_function : COS factor              { $$ = cos($2); }
     | SIN factor                       { $$ = sin($2); }
     | TAN factor                       { $$ = tan($2); }
     ;

standard_function : factor MOD factor     { $$ = modulo($1, $3); }
     | FLOOR factor                     { $$ = floor($2); }
     | CEIL factor                      { $$ = ceil($2); }
     | ABS factor                       { $$ = fabs($2); }
     | SQRT factor                      { $$ = sqrt($2); }
     | factor FACTORIAL                 { $$ = factorial($1); }
     ;

log_function : LOG2 factor              { $$ = log2($2); }
     | LOG10 factor                     { $$ = log10($2); }  
     ;

conversion : factor GBP_TO_USD            { $$ = gbp_to_usd($1); }
     | factor USD_TO_GBP                  { $$ = usd_to_gbp($1); } 
     | factor GBP_TO_EURO                 { $$ = gbp_to_euro($1); }
     | factor EURO_TO_GBP                 { $$ = euro_to_gbp($1); }
     | factor USD_TO_EURO                 { $$ = usd_to_gbp($1); }
     | factor EURO_TO_USD                 { $$ = euro_to_gbp($1); }
     | factor CEL_TO_FAH                  { $$ = cel_to_fah($1); }
     | factor FAH_TO_CEL                  { $$ = fah_to_cel($1); }
     | factor MI_TO_KM                    { $$ = m_to_km($1); }
     | factor KM_TO_MI                    { $$ = km_to_m($1); }

assignment : VAR_KEYWORD VARIABLE EQUALS expr EOL { 
                                             put_var($2, $4);
                                        }
%%

int main()
{
    yyparse(); // A parsing function that will be generated by Bison.
    return 0;
}
